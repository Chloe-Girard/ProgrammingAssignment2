## The two functions work together and aim at storing in memory (cache) the inverse of a matrix m.
## makeCacheMatrix allows the creation of a list containing the inverse of the matrix m IF AND WHEN cacheSolve is called.
## cacheSolve computes the inverse of the matrix m fed into makeCacheMatrix IF AND ONLY IF it hasn't been already calculated 
## (if it has, the inverse was stored in the list created by makeCacheMatrix, and this results is called without having to 
## compute it again)

## makeCacheMatrix takes as argument an inversible matrix m that you want to inverse
## It returns a list of functions (set, get, setinv, getinv), allowing to store the inverse (inv) when the cacheSolve function
## is called.

## NB: when a function fits on one line, there is no need to use {}
# so line 20 get <- funcion() m is the same as get <- function () {m}

makeCacheMatrix <- function(m = matrix()) { #argument must be a matrix
      inverse <- matrix(nrow=nrow(m),ncol=ncol(m)) #initiates an empty matrix of same dimension as m full of NAs
      set <- function(n){
            m <<- n
            inverse <<- matrix(nrow=nrow(m),ncol=ncol(m)) ## restores "inverse" as an empty matrix if m is different
      }
      get <- function() m #gets the input m
      setinv <- function(inv) inverse <<- inv #sets inverse to be the inverse of m when cacheSolve is called
      getinv <- function() inverse #returns inverse 
      list(set=set, get = get, setinv=setinv, getinv=getinv)
}

## cacheSolve takes as argument a list (mlist) generated by makeCacheMatrix
## It returns the inverse of the matrix m (fed to makeCacheMatrix) by either 
## 1/ calculating it with the function solve IF it hasn't been computed before, and storing it in mlist
## 2/ retreiving it from mlist IF it was already computed by a previous call of cacheSolve 

cacheSolve <- function(mlist, ...) { #mlist is the list resulting from makeCacheMatrix(m)
      inv.local <- mlist$getinv() #"inverse local", gets the value of getinv from makeCacheMatrix(m)
      if(!is.na(inv.local[1])) { #if the inverse has already been calculated (inv.local is not full of NAs), then you retrieve the value
            message("getting cached data")
            return(inv.local)
      } else { 
      matrix.input <- mlist$get() #element of the list "get", which correspond to the matrix entered as argument of makeCacheMatrix
      inv.local.calculated <- solve(matrix.input, ...) #cumputes the inverse of the matrix
      mlist$setinv(inv.local.calculated) #sets the value of setinv as the inversed matrix inside the list created by makeCacheMatrix
      inv.local.calculated #displays the inversed matrix
  	}
} 